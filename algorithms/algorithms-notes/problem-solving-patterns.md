# Problem solving patterns

## Frequency counter pattern
* Uses objects or sets to collect values/ frequencies of values
* This pattern helps to avoid the O(N^2) solution using nested loops to compare values

### Examples 
* Check for anagrams

## Multiple Pointers pattern
* Create pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition
* Very efficient for solving problems with minimum space complexity as well

### Examples 
* Linked List - Check if a Linked-List is cyclic, Finding the mid-point of a linked list 
* Finding the first pair where the sum is zero in a sorted array
* Count unique values in a sorted array

## Sliding Window pattern
* Involves creating a window which can either be an array or number from one position to another
* Depending upon a certain condition, the window either increases or closes (and a new window is created)
* Useful for keeping track of a subset of data in an array/ string

### Examples
* Calculate the maximum sum of n consecutive elements in an array of integers

## Divide and Conquer pattern
* This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data
* This pattern can tremendously decrease time complexity

### Examples
* Searching for an integer in a sorted array of integers
* Binary search tree
